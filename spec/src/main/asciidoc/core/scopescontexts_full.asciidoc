[[contexts_full]]

== Scopes and contexts in {cdi_full}


[[dependent_context_full]]

=== Dependent pseudo-scope in {cdi_full}


[[dependent_objects_full]]

==== Dependent objects in {cdi_full}

In addition to rules defined in <<dependent_objects>>, when running in {cdi_full}, the following apply:

* Instances of decorators and interceptors are dependent objects of the bean instance they decorate.


[[passivating_scope_full]]

=== Passivation and passivating scopes in {cdi_full}


[[passivation_capable_full]]

==== Passivation capable beans

In addition to rules defined in <<passivation_capable>>, when running in {cdi_full}, the following apply:


* A managed bean is passivation capable if and only if the bean class is serializable and all interceptors and decorators of the bean are passivation capable.


[[passivation_validation_full]]

==== Validation of passivation capable beans and dependencies in {cdi_full}

In addition to rules defined in <<passivation_validation>>, when running in {cdi_full}, the following apply:
If a managed bean which declares a passivating scope, or a built-in bean:

* has a decorator that is not passivation capable
* has a decorator with an injection point that is not passivation capable


If a managed bean which declares a passivating scope type, has a decorator which is not a passivation capable dependency, the container automatically detects the problem and treats it as a deployment problem.

[[builtin_contexts_full]]

=== Context management for built-in scopes in {cdi_full}

[[conversation_context_full]]

==== Conversation context lifecycle

The _conversation context_ is provided by a built-in context object for the built-in passivating scope type `@ConversationScoped`.

[[conversation_full]]

==== The `Conversation` interface

The container provides a built-in bean with bean type `Conversation`, scope `@RequestScoped`, and qualifier `@Default`, named `jakarta.enterprise.context.conversation`.

[source, java]
----
public interface Conversation {
   public void begin();
   public void begin(String id);
   public void end();
   public String getId();
   public long getTimeout();
   public void setTimeout(long milliseconds);
   public boolean isTransient();
}
----

* `begin()` marks the current transient conversation long-running. A conversation identifier may, optionally, be specified.
If no conversation identifier is specified, an identifier is generated by the container.
* `end()` marks the current long-running conversation transient.
* `getId()` returns the identifier of the current long-running conversation, or a null value if the current conversation is transient.
* `getTimeout()` returns the timeout, in milliseconds, of the current conversation.
* `setTimeout()` sets the timeout of the current conversation.
* `isTransient()` returns `true` if the conversation is marked transient, or `false` if it is marked long-running.


If any method of `Conversation` is called when the conversation scope is not active, a `ContextNotActiveException` is thrown.

If `end()` is called, and the current conversation is marked transient, an `IllegalStateException` is thrown.

If `begin()` is called, and the current conversation is already marked long-running, an `IllegalStateException` is thrown.

If `begin()` is called with an explicit conversation identifier, and a long-running conversation with that identifier already exists, an `IllegalArgumentException` is thrown.
