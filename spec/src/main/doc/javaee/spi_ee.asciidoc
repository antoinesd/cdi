[[spi_ee]]

== Portable extensions in Java EE

[[interceptor_ee]]

==== The +Interceptor+ interface in Java EE

When Running in Java EE, the container must extend the rules defined in <<interceptor>> and must also ensure that
 
`PRE_PASSIVATE`, `POST_ACTIVATE` and `AROUND_TIMEOUT` InterceptorType value are linked to EJB lifecycle callback or method timeout. 

[[injectiontarget_ee]]

=== +InjectionTarget+ interface in Java EE

When running in Java EE, the container must extend the rules defined for `InjectionTarget` in <<injectiontarget>> and must also ensure that:

* when +inject()+ is called, The container performs Java EE component environment injection, according to the semantics required by the Java EE platform specification, sets the value of all injected fields, and calls all initializer methods, as defined in <<fields_initializer_methods_ee>>.
* +@PostConstruct+ callback is called according to the semantics required by the Java EE platform specification.
* +@PreDestroy+ callback is called according to the semantics required by the Java EE platform specification.


[[beanmanager_ee]]

=== The +BeanManager+ object in Java EE

[[provider_ee]]

==== Obtaining a reference to the CDI container in Java EE

A Java EE container is required to provide a CDI provider that will allow access to the current container for any Java EE application or Java EE module which contains enabled beans.

Java EE Components may obtain an instance of +BeanManager+ from JNDI by looking up the name +java:comp/BeanManager+.

[[bm_wrap_expressionfactory]]

==== Wrapping a Unified EL +ExpressionFactory+

The method +BeanManager.wrapExpressionFactory()+ returns a wrapper +javax.el.ExpressionFactory+ that delegates +MethodExpression+ and +ValueExpression+ creation to the given +ExpressionFactory+. When a Unified EL expression is evaluated using a +MethodExpression+ or +ValueExpression+ returned by the wrapper +ExpressionFactory+, the rules defined in <<dependent_scope_el>> are enforced by the container.

[source, java]
----
public ExpressionFactory wrapExpressionFactory(ExpressionFactory expressionFactory);
----


[[init_events_ee]]

=== Addition to Container lifecycle events in Java EE

[[process_injection_point_ee]]

==== `ProcessInjectionPoint` event and EJB

When running in Java EE, the container must also fire an event for every injection point of every EJB session or message-driven bean.

[[process_injection_target_ee]]

==== `ProcessInjectionTarget` event

When running in Java EE, the container must also fire an event for every EJB session or message-driven bean.

[[process_bean_ee]]

==== `ProcessBean` event and EJB

In addition to definition given in <<process_bean>> the following apply:

* For a session bean with bean class `X`, the container must raise an event of type `ProcessSessionBean<X>`.

Resources are considered to be producer fields.

When running in Java EE, the interface `javax.enterprise.inject.spi.ProcessBean` is also a supertype of `javax.enterprise.inject.spi.ProcessSession` :

[source, java]
----
public interface ProcessSessionBean<X>
        extends ProcessManagedBean<Object> {
    public String getEjbName();
    public SessionBeanType getSessionBeanType();
}
----

* `getEjbName()` returns the EJB name of the session bean.
* `getSessionBeanType()` returns a `javax.enterprise.inject.spi.SessionBeanType` representing the kind of session bean.

[source, java]
----
public enum SessionBeanType { STATELESS, STATEFUL, SINGLETON }
----
